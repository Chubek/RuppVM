; Stack operations
load_const      ( -- v)        		; Push a constant onto the stack
store           ( v -- )       		; Pop the top stack v and store it in a local variable
load            ( -- v)        		; Push the v of a local variable onto the stack
dup             ( v -- v v)  		; Duplicate the top v on the stack
drop            ( v -- )        	; Remove the top v from the stack
swap            ( v1 v2 -- v2 v1)	; Swap the top two vs on the stack
over            ( v1 v2 -- v1 v2 v1) 	; Duplicate the second item on the stack over the top item
rot2            ( v1 v2 -- v2 v1) 	; Rotate the top two stack vs
rot3            ( v1 v2 v3 -- v2 v3 v1) ; Rotate the top three stack vs
pick            ( n -- v)       	;Copy the nth item from the top of the stack to the top

; Control flow operations
call		( v n --  )	        ; Call function at address v, passing n items on stack
extcall		( v n --  )	        ; Call external function at v, passing n items on stack
jmp             ( v --  )      	        ; Perform an unconditional jump to address v
jmpz		( v1 v2 -- )		; Jump to v1 if v2 is 0
jmpnz		( v1 v2 -- )		: Jump to v1 if v2 is not 0
jmpeq		( v1 v2 v3 -- )  	; Jump to v1 if v2 equals v3
jmpne		( v1 v2 v3 -- )		; Jump to v1 if v2 does not equal v3
jmplt		( v1 v2 v3 -- )		; Jump to v1 if v2 is lesser than v3
jmple		( v1 v2 v3 -- )		; Jump to v1 if v2 is lesser/equal than/to v3
jmpgt		( v1 v2 v3 -- )		; Jump to v1 if v2 is greater than v3
jmpge		( v1 v2 v3 -- )		; Jump to v1 if v2 is greater/equal than/to v3
skipz           ( v -- )                ; Skip next op if v is 0
skipnz          ( v -- )                : Skip next op if v is not
skipeq          ( v1 v2 -- )            ; Skip next op if v1 equals v2
skipne          ( v1 v2 -- )            ; Skip next op if v1 does not equal v2
skiplt          ( v1 v2 -- )            ; Skip next op if v1 is lesser than v2
skiple          ( v1 v2 -- )            ; Skip next op if v2 is lesser/equal than/to v2
skipgt          ( v1 v2 -- )            ; Skip next op if v1 is greater than v2
skipge          ( v1 v2 -- )            ; Skip next op if v1 is greater/equal than/to v2
enter		(  --  )		; Enter function, create a new stack frame
leave		(  --  )		; Leave function, destroy stack frame
nop		(  --  )                ; No operation
enter_crit	(  --  )		; Entering critical execution zone
exit_crit	(  --  )		; Exiting critical execution zone

; Arithmetic operations
add		( v1 v2 -- v )		; Add v1 to v2
sub		( v1 v2 -- v )		; Subtract v2 from v1
subr		( v1 v2 -- v ) 		; Subtract v1 from v2
mul		( v1 v2 -- v )		; Multiply v1 with v2
div		( v1 v2 -- v )		; Divide v1 by v2
mod		( v1 v2 -- v )		; Modulo of v1 by v2 division
and		( v1 v2 -- v )		; Bitwise-and v1 with v2
or		( v1 v2 -- v )		; Bitwise-or v1 with v2
xor 		( v1 v2 -- v )		; Bitwise-xor v1 with v2
shr		( v1 v2 -- v )		; Right-shift v1 v2 times
shl		( v1 v2 -- v )		; Left-shift v1 v2 times

; Thread operations
mk_thrd	        ( v -- vthread )         ; Creates a new green thread with address v, returns handle as vthread
join_thrd	( vthread --   )	 ; Wait until vthread joins
wait_thrd	( -- )			 ; Wait until current thread finishes
yield_thrd	( -- )			 ; Yield the execution of current thread, let the scheduler bring up next availalbe thread
lock_req  	( vzone -- vgrant )	 ; Request access to critical zone at address 'vzone', returns 'vgrant' as permission
lock_acc	( vzone vgrant -- )	 ; Acquire a lock at critical zone 'vzone' with grant 'vgrant'
lock_rls	( vgrant -- )		 ; Release lock associated with 'vgrant'



